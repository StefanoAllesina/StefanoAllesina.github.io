//////////////////////////////////////////////////////////////////////////////////
// Stefano Allesina Dec 2009 
// sallesina@uchicago.edu
// Given a matrix generated by the niche model and a vector containing
// the positions of the species used to generate the matrix, finds the likelihood.
//////////////////////////////////////////////////////////////////////////////////
// Compile
// gcc NewNicheLikelihood.c -o LNICHE -lgsl -lgslcblas -Wall -DHAVE_INLINE -O3
//////////////////////////////////////////////////////////////////////////////////
// Run
// ./LNICHE 4 Matrix4.txt Vec4.txt
// Where:
// * 4 is the number of species
// * Matrix4.txt is a text file containing a space separated adjacency matrix
//               where the rows are the resources and the cols are the consumers
// * Vec4.txt is a space separated text file containing the positions (in [0,1.0])
//            of the species
//////////////////////////////////////////////////////////////////////////////////
// Output
// NONE
//////////////////////////////////////////////////////////////////////////////////

#include<stdio.h>
#include<math.h>
#include <stdlib.h>
#include<gsl/gsl_math.h>
#include<gsl/gsl_integration.h>
#include<gsl/gsl_vector.h>
#include<gsl/gsl_matrix.h>
#include<gsl/gsl_rng.h>
#include<gsl/gsl_randist.h>
#include<gsl/gsl_cdf.h>
#include<gsl/gsl_blas.h>
#include<gsl/gsl_linalg.h>
#include<gsl/gsl_permutation.h>
#include<gsl/gsl_sort_vector_double.h>
#include <gsl/gsl_monte.h>
#include <gsl/gsl_monte_plain.h>
#include <gsl/gsl_monte_miser.h>
#include <gsl/gsl_monte_vegas.h>

// GLOBAL FILE FOR OUTPUT
FILE * FOUT;

// Structure needed for numerical integration
struct myP { double nlm1; double nl; double nr; double nrp1; double n; double beta;};

// UTILITIES
int PrintAdjMat(gsl_matrix * X, int a){
  int i,j;
  for (i=0;i<a;i++){
      for (j=0;j<a;j++){
	fprintf(FOUT,"%1.0f ",gsl_matrix_get(X,i,j));
      }
      fprintf(FOUT,"\n");
  }
  return 0;
}
int PrintVector(gsl_vector * X, int a){
  int i;
  for (i=0;i<a;i++){
    fprintf(FOUT,"%1.3f ",gsl_vector_get(X,i));
  }
  fprintf(FOUT,"\n");
  return 0;
}
// END UTILITIES

// INTEGRATION FOR CONSUMERS
double Inte(double x, void *p){
  struct myP * params  = (struct myP *)p;
  double nlm1=(params->nlm1);
  double nl=(params->nl);
  double nr=(params->nr);
  double nrp1=(params->nrp1);
  double n=(params->n);
  double beta=(params->beta);
  double res=0;
  res=gsl_ran_beta_pdf(x,1.0,beta);
  //fprintf(stderr,"Pdf %f\n",res);
  // Difference
  double c0,c1;
  double r2=(double )x*n/2.;
  if (x*n<=GSL_MIN_DBL(nr-nlm1,nrp1-nl)){
    // case '
    c0=GSL_MIN_DBL(n,nr-r2);
    c1=GSL_MIN_DBL(n,nl+r2);
  }
  else{
    if (x*n<=GSL_MAX_DBL(nr-nlm1,nrp1-nl)){
      // case ''
      if ((nr-nlm1)<=(nrp1-nl)){
	// a<=b
	c0=GSL_MIN_DBL(n,nlm1+r2);
	c1=GSL_MIN_DBL(n,nl+r2);
      }
      else{
	// b<a
	c0=GSL_MIN_DBL(n,nr-r2);
	c1=GSL_MIN_DBL(n,nrp1-r2);
      }
    }
    else{
      // case '''
      c0=GSL_MIN_DBL(n,nlm1+r2);
      c1=GSL_MIN_DBL(n,nrp1-r2);
    }
  }
  res*=(c1-c0);
  //fprintf(stderr,"Center %f (%f)\n",res,(c1-c0));
  // Normalization
  if ((n+r2)<1.0){
    res/=(n-r2);
  }
  else{
    res/=(1.0-2.0*r2);
  }
  //fprintf(stderr,"Rescale %f\n",res);
  return (res);
}

double Integrate (double nlm1, double nl, double n, double nr, double nrp1, double Beta){
  double error;
  double result;
  double low,upp;
  gsl_function F;
  struct myP params = { 0., 0., 0., 0., 0., 0.}; 
  // setup the environment
  gsl_integration_workspace * w= gsl_integration_workspace_alloc (10000);
  params.beta=Beta;
  params.nlm1=nlm1;
  params.nl=nl;
  params.n=n;
  params.nr=nr;
  params.nrp1=nrp1;
  
  F.function = &Inte;
  F.params = &params;
  low=GSL_MIN_DBL((nr-nl)/n,1.0);
  upp=GSL_MIN_DBL((nrp1-nlm1)/n,1.0);
  gsl_integration_qags(&F,low,upp,0,1e-4,10000,w,&result, &error);
  //fprintf(stderr,"Prob %f\n",result);
  if (result==0.0) {
    fprintf(FOUT,"The diet is incompatible with the niche model!!\n");
    return -10000.0; // The diet is impossible!
  }
  return log(result);
}

// INTEGRATION FOR BASAL SPECIES
double InteBasal(double x, void *p){
  struct myP * params  = (struct myP *)p;
  double nlm1=(params->nlm1);
  double nrp1=(params->nrp1);
  double n=(params->n);
  double beta=(params->beta);
  double res=0;
  res=gsl_ran_beta_pdf(x,1.0,beta);
  double r2=(double )x*n/2.;
  double c1=nrp1-r2;
  double c0=nlm1+r2;
  res*=(c1-c0);
  //fprintf(stderr,"Center %f (%f)\n",res,(c1-c0));
  // Normalization
  if ((n+r2)<1.0){
    res/=(n-r2);
  }
  else{
    res/=(1.0-2.0*r2);
  }
  return (res);
}

double IntegrateBasal(double GapLeft, double GapRight, double n, double Beta){
  double error;
  double result;
  double low,upp;
  gsl_function F;
  struct myP params = { 0., 0., 0., 0., 0., 0.}; 
  // setup the environment
  gsl_integration_workspace * w= gsl_integration_workspace_alloc (10000);
  params.beta=Beta;
  params.nlm1=GapLeft;
  params.nl=0.0;
  params.n=n;
  params.nr=0.0;
  params.nrp1=GapRight;
  
  F.function = &InteBasal;
  F.params = &params;
  low=GSL_MIN_DBL(0.0,1.0);
  upp=GSL_MIN_DBL((GapRight-GapLeft)/n,1.0);
  gsl_integration_qags(&F,low,upp,0,1e-4,10000,w,&result, &error);
  //fprintf(stderr,"Prob %f\n",result);
  if (result==0.0) {
    fprintf(FOUT,"The diet is incompatible with the niche model!!\n");
    return -10000000.0; // The diet is impossible!
  }
  return (result);
}

// COMPUTE THE LIKELIHOOD OF A MATRIX PERFECTLY COMPATIBLE WITH THE NICHE MODEL
double ComputeLikelihood(gsl_matrix *A, gsl_vector *Pos, int N, double Beta){
  double Prob=0.0;
  int i,j;
  double nlm1, nl, n, nr, nrp1;
  double TmpProb;
  for (i=0;i<N;i++){
    if (gsl_matrix_get(A,i,0)==1){
      fprintf(FOUT,"The first species is not basal!!\n");
      Prob-=100000000.0;
    }
  }
  if (Prob>-1.0) fprintf(FOUT,"First    Sp 0, LogLikelihood Diet 0.0 (1.0)\n");
  for (i=1;i<N;i++){
    n=gsl_vector_get(Pos,i);
    nlm1=nl=0.0;
    nr=nrp1=1.0;
    // Find first prey
    for (j=0;j<N;j++){
      if (gsl_matrix_get(A,j,i)==1){
	nl=gsl_vector_get(Pos,j);
	if (j>0){
	  nlm1=gsl_vector_get(Pos,j-1);
	}
	break;
      }
    }
    if (nl>0.0){
      // i is a predator
      // Find the last prey
      for (j=N-1;j>=0;j--){
	if (gsl_matrix_get(A,j,i)==1){
	  nr=gsl_vector_get(Pos,j);
	  if (j<(N-1)){
	    nrp1=gsl_vector_get(Pos,j+1);
	  }
	  break;
	}
      }
      // Now compute the probability
      TmpProb=0.0;
      //fprintf(stderr,"Computing probability of %d (%f %f %f %f %f) Beta: %f\n", i, nlm1, nl, n, nr, nrp1, Beta);
      TmpProb=Integrate(nlm1, nl, n, nr, nrp1, Beta);
      fprintf(FOUT,"Consumer Sp %d, LogLikelihood Diet %f (%f)\n",i,TmpProb,exp(TmpProb));
      Prob+=TmpProb;
    }
    else{
      TmpProb=0.0;
      // for each species compute the probability that the species is not eating any one in between
      double GapLeft, GapRight;
      for (j=0;j<=i;j++){
	if (j==0){
	  GapLeft=0.0;
	}
	else{
	  GapLeft=gsl_vector_get(Pos,j-1);
	}
	GapRight=gsl_vector_get(Pos,j);
	//fprintf(stderr,"Left: %f Right:%f Cumulative: %f\n",GapLeft,GapRight,TmpProb);
	TmpProb+=IntegrateBasal(GapLeft,GapRight, n,Beta);
      }
      fprintf(FOUT,"Basal    Sp %d, LogLikelihood Diet %f (%f)\n",i,log(TmpProb),TmpProb);      
      // now that you have summed across all possibilities take the log and sum it 
      Prob+=log(TmpProb);
    }
  }
  return Prob;
}

// READ THE MATRIX AND RUN THE PROBABILITY
// Main
int main(int argc, char *argv[]){
  // First argument: number of species
  int Sp=atoi(argv[1]);
  char * FileMat=(argv[2]);
  char * FilePos=(argv[3]);
  // Read the matrix
  FILE * F;
  // matrix
  gsl_matrix * A =gsl_matrix_calloc(Sp,Sp);
  F=fopen(FileMat,"rb");
  gsl_matrix_fscanf(F,A);
  fclose(F);
  int i,j;
  double C,Beta;
  C=Beta=0.0;
  // compute the C and Beta
  for (i=0;i<Sp;i++){
    for (j=0;j<Sp;j++){
      if(gsl_matrix_get(A,i,j)==1) C+=1.0;
    }
  }
  C=(double)C/(double)Sp/(double)Sp;
  Beta=((double) Sp -1.0)/(2.0*C*(double) Sp) -1.0;
  char OutFile[200];
  sprintf(OutFile,"Output-%s",FileMat);
  if ((FOUT = fopen(OutFile, "w")) == NULL){
    puts("Unable to open the file");
    return 0;
  }
  // read the vector
  gsl_vector * Eta=gsl_vector_calloc(Sp);
  F=fopen(FilePos,"rb");
  gsl_vector_fscanf(F,Eta);
  fclose(F);
  fprintf(FOUT,"Compatible Adjacency Matrix\n");
  PrintAdjMat(A,Sp);
  fprintf(FOUT,"Species Positions\n");
  PrintVector(Eta,Sp);
  fprintf(FOUT,"Beta: %f\n",Beta);
  fprintf(FOUT,"LogLikelihood: %f\n",ComputeLikelihood(A,Eta,Sp,Beta));
  gsl_matrix_free(A);
  gsl_vector_free(Eta);
  fclose(FOUT);
  return 0;
}
